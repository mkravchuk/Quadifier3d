// This file is part of libigl, a simple c++ geometry processing library.
//
// Copyright (C) 2014 Alec Jacobson <alecjacobson@gmail.com>
//
// This Source Code Form is subject to the terms of the Mozilla Public License
// v. 2.0. If a copy of the MPL was not distributed with this file, You can
// obtain one at http://mozilla.org/MPL/2.0/.
#include "local_basis.h"

#include <sstream>
#include <string>
#include <fstream>

#include <vector>
#include <Eigen/Geometry>


template <typename DerivedV, typename DerivedF>
IGL_INLINE void igl::local_basis(
  const Eigen::PlainObjectBase<DerivedV>& V,
  const Eigen::PlainObjectBase<DerivedF>& F,
  Eigen::PlainObjectBase<DerivedV>& B1,
  Eigen::PlainObjectBase<DerivedV>& B2,
  Eigen::PlainObjectBase<DerivedV>& B3
  )
{
    // v1 - origin - slow
    //using namespace Eigen;
    //using namespace std;
    //B1.resize(F.rows(), 3);
    //B2.resize(F.rows(), 3);
    //B3.resize(F.rows(), 3);

    //for (unsigned i = 0; i<F.rows(); ++i)
    //{
    //    Eigen::Matrix<typename DerivedV::Scalar, 1, 3> v1 = (V.row(F(i, 1)) - V.row(F(i, 0))).normalized();
    //    Eigen::Matrix<typename DerivedV::Scalar, 1, 3> t = V.row(F(i, 2)) - V.row(F(i, 0));
    //    Eigen::Matrix<typename DerivedV::Scalar, 1, 3> v3 = v1.cross(t).normalized();
    //    Eigen::Matrix<typename DerivedV::Scalar, 1, 3> v2 = v1.cross(v3).normalized();

    //    B1.row(i) = v1;
    //    B2.row(i) = -v2;
    //    B3.row(i) = v3;
    //}

    //v2 - Mupoc - fast - all Eigen method breaked apart to be inlined 
  using namespace Eigen;
  using namespace std;
  int rows = F.rows();
  B1.resize(rows,3);
  B2.resize(rows,3);
  B3.resize(rows,3);

  for (unsigned i=0;i<rows;++i)
  {
      int fi0 = F(i, 0);
      int fi1 = F(i, 1);
      int fi2 = F(i, 2);
      Eigen::Matrix<typename DerivedV::Scalar, 1, 3> vertex0 = V.row(fi0);
      Eigen::Matrix<typename DerivedV::Scalar, 1, 3> v1n = V.row(fi1);
      v1n -= vertex0;
      Eigen::Matrix<typename DerivedV::Scalar, 1, 3> t = V.row(fi2);
      t -= vertex0;
      v1n.normalize();
      Eigen::Matrix<typename DerivedV::Scalar, 1, 3> v3n = v1n.cross(t);
      v3n.normalize();
      Eigen::Matrix<typename DerivedV::Scalar, 1, 3> v2n = v1n.cross(v3n);
      v2n.normalize();
      B1(i, 0) = v1n(0);
      B1(i, 1) = v1n(1);
      B1(i, 2) = v1n(2);
      B2(i, 0) = -v2n(0);
      B2(i, 1) = -v2n(1);
      B2(i, 2) = -v2n(2);
      B3(i, 0) = v3n(0);
      B3(i, 1) = v3n(1);
      B3(i, 2) = v3n(2);
  }
}

#ifdef IGL_STATIC_LIBRARY
// Explicit template specialization
// generated by autoexplicit.sh
template void igl::local_basis<Eigen::MatrixX3d, Eigen::MatrixX3i >(Eigen::PlainObjectBase<Eigen::MatrixX3d > const&, Eigen::PlainObjectBase<Eigen::MatrixX3i > const&, Eigen::PlainObjectBase<Eigen::MatrixX3d >&, Eigen::PlainObjectBase<Eigen::MatrixX3d >&, Eigen::PlainObjectBase<Eigen::MatrixX3d >&);
template void igl::local_basis<Eigen::MatrixXd, Eigen::MatrixXi >(Eigen::PlainObjectBase<Eigen::MatrixXd > const&, Eigen::PlainObjectBase<Eigen::MatrixXi > const&, Eigen::PlainObjectBase<Eigen::MatrixXd >&, Eigen::PlainObjectBase<Eigen::MatrixXd >&, Eigen::PlainObjectBase<Eigen::MatrixXd >&);
#endif
