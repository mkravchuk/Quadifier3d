// This file is part of libigl, a simple c++ geometry processing library.
//
// Copyright (C) 2013 Alec Jacobson <alecjacobson@gmail.com>
//
// This Source Code Form is subject to the terms of the Mozilla Public License
// v. 2.0. If a copy of the MPL was not distributed with this file, You can
// obtain one at http://mozilla.org/MPL/2.0/.
#include "is_edge_manifold.h"
#include "all_edges.h"
#include "unique_simplices.h"
#include "triangle_triangle_adjacency.h"

#include <algorithm>
#include <vector>

template <
  typename DerivedF,
  typename DerivedBF,
  typename DerivedE,
  typename DerivedEMAP,
  typename DerivedBE>
IGL_INLINE bool igl::is_edge_manifold(
  const Eigen::PlainObjectBase<DerivedF>& F,
  Eigen::PlainObjectBase<DerivedBF>& BF,
  Eigen::PlainObjectBase<DerivedE>& E,
  Eigen::PlainObjectBase<DerivedEMAP>& EMAP,
  Eigen::PlainObjectBase<DerivedBE>& BE)
{
  using namespace Eigen;
  typedef typename DerivedF::Index Index;
  typedef Matrix<typename DerivedF::Scalar,Dynamic,1> VectorXF;
  typedef Matrix<typename DerivedF::Scalar,Dynamic,2> MatrixXF2;
  MatrixXF2 allE;
  all_edges(F,allE);
  // Find unique undirected edges and mapping
  VectorXF _;
  unique_simplices(allE,E,_,EMAP);
  std::vector<typename DerivedF::Index> count(E.rows(),0);
  for(Index e = 0;e<EMAP.rows();e++)
  {
    count[EMAP[e]]++;
  }
  const Index m = F.rows();
  BF.resize(m,3);
  BE.resize(E.rows(),1);
  bool all = true;
  for(Index e = 0;e<EMAP.rows();e++)
  {
    const bool manifold = count[EMAP[e]] <= 2;
    all &= BF(e%m,e/m) = manifold;
    BE(EMAP[e]) = manifold;
  }
  return all;
}

template <typename DerivedF>
IGL_INLINE bool igl::is_edge_manifold(
  const Eigen::PlainObjectBase<DerivedF>& F)
{
  // TODO: It's bothersome that this is not calling/reusing the code from the
  // overload above. This could result in disagreement.
  // List of edges (i,j,f,c) where edge i<j is associated with corner i of face f
    std::vector<std::vector<int> > TTT;
    triangle_triangle_adjacency_preprocess(F, TTT);
    return is_edge_manifold(F, TTT);
}

template <typename DerivedF, typename TTT_type>
IGL_INLINE bool igl::is_edge_manifold(
    const Eigen::PlainObjectBase<DerivedF>& F,
    const std::vector<std::vector<TTT_type> >& TTT)
{
    for (int i = 2; i<(int)TTT.size(); ++i)
    {
        // Check any edges occur 3 times
        const std::vector<int>& r1 = TTT[i - 2];
        const std::vector<int>& r2 = TTT[i - 1];
        const std::vector<int>& r3 = TTT[i];
        if ((r1[0] == r2[0] && r2[0] == r3[0])
            &&
            (r1[1] == r2[1] && r2[1] == r3[1]))
        {
            return false;
        }
    }
    return true;
}


#ifdef IGL_STATIC_LIBRARY
// Explicit template specialization
// generated by autoexplicit.sh
//template bool igl::is_edge_manifold<Eigen::Matrix<unsigned int, -1, -1, 1, -1, -1> >(Eigen::PlainObjectBase<Eigen::Matrix<unsigned int, -1, -1, 1, -1, -1> > const&);
// generated by autoexplicit.sh
//template bool igl::is_edge_manifold<double>(Eigen::MatrixXd const&, Eigen::MatrixXi const&);
template bool igl::is_edge_manifold<Eigen::MatrixXi >(Eigen::PlainObjectBase<Eigen::MatrixXi > const&);
template bool igl::is_edge_manifold<Eigen::MatrixX3i >(Eigen::PlainObjectBase<Eigen::MatrixX3i > const&);
template bool igl::is_edge_manifold<Eigen::MatrixXi, int >(Eigen::PlainObjectBase<Eigen::MatrixXi > const&, std::vector<std::vector<int>>const&);
#endif
