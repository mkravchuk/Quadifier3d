#include "stdafx.h"
#include "OpenGL_TransformFeedback.h"

OpenGL_TransformFeedback::OpenGL_TransformFeedback()
    : isCreated(false), RASTERIZER_DISCARD(true), query_primitivesWRITTEN(false), query(0),
     primitiveMode(GL_POINTS), primitivesWRITTEN(0), tbo(0)
{
    ClearCounters();
}

OpenGL_TransformFeedback::~OpenGL_TransformFeedback()
{
    Delete();
}

void OpenGL_TransformFeedback::Create(GLenum _primitiveMode, bool _RASTERIZER_DISCARD, bool _query_primitivesWRITTEN)
{
    primitiveMode = _primitiveMode;
    RASTERIZER_DISCARD = _RASTERIZER_DISCARD;
    query_primitivesWRITTEN = _query_primitivesWRITTEN;

    Delete();
    glGenBuffers(1, &tbo);
    isCreated = true;
}

void OpenGL_TransformFeedback::Delete()
{
    if (isCreated)
    {
        glDeleteBuffers(1, &tbo);
        tbo = 0;
        isCreated = false;
    }
    variables.clear();
    variablesSizesInBytes.clear();
}

void OpenGL_TransformFeedback::ClearCounters()
{
    query = 0;
    primitivesWRITTEN = 0;
}

void OpenGL_TransformFeedback::Begin_CatchShadersOutput()
{
    assert(isCreated);
    if (query_primitivesWRITTEN)
    {
        primitivesWRITTEN = 0;
        glGenQueries(1, &query);
        glBeginQuery(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, query);
    }

    if (RASTERIZER_DISCARD)
    {
        gl::Enable(GL_RASTERIZER_DISCARD);
    }

    glBeginTransformFeedback(primitiveMode);
}

void OpenGL_TransformFeedback::End_CatchShadersOutput(bool showDebugInfo)
{
    assert(isCreated);
    glEndTransformFeedback();

    if (RASTERIZER_DISCARD)
    {
        gl::Disable(GL_RASTERIZER_DISCARD);
    }

    if (query_primitivesWRITTEN)
    {
        glEndQuery(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
        glGetQueryObjectuiv(query, GL_QUERY_RESULT, &primitivesWRITTEN);
        if (showDebugInfo)
        {
            printf("TransformFeedback:  %u primitives catched!\n\n", primitivesWRITTEN);
        }
    }
}

void OpenGL_TransformFeedback::BindBuffer(const MatrixXf& buffer, int countOfElementsInRow)
{
    assert(isCreated);
    // GL_INTERLEAVED_ATTRIBS - varying variables for the vertices of each primitive generated by the GL are written to a SINGLE buffer
    // GL_SEPARATE_ATTRIBS      - varying variables for the vertices of each primitive generated by the GL are written to a MULTIPLE buffers
    if (tbo == -1) return;

    int outSizeForVertexInBytes = GetVariablesSumSizeInBytes();

    //v0 - write to multiple buffers - dont works and will be slower from 'v1 writing to single buffer'
    //for (int i = 0; i < tbos.size(); i++)
    //{
    //    glBindBuffer(GL_ARRAY_BUFFER, tbos[i]);
    //    glBufferData(GL_ARRAY_BUFFER, feedbackVaryingsSizes[i] * V_vbo.rows(), nullptr, GL_STATIC_READ);// here nullptr - Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
    //    glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, i, tbos[i]);
    //}
    //outSizeForVertexInBytes *= 1;// allocate more space, to be sure that buffer have enought space to record all outputs. There is a issue in OpenGL that last value is not recorded - additional space will fix the issue.

    // v1 writing to single buffer
    glBindBuffer(GL_ARRAY_BUFFER, tbo);
    int size = buffer.rows()*countOfElementsInRow*outSizeForVertexInBytes;
    size *= 2; // allocate double size - this is attempt so solve issue with GPU hang
    glBufferData(GL_ARRAY_BUFFER, size, nullptr, GL_STATIC_DRAW);// GL_STATIC_DRAW - if we using feedback buffer for drawing.  here nullptr - Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
    glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, 0, tbo);
}

int OpenGL_TransformFeedback::GetVariablesSumSizeInBytes()
{
    assert(isCreated);
    int sum = 0;
    for (int i = 0; i < variablesSizesInBytes.size(); i++)
    {
        sum += variablesSizesInBytes[i];
    }
    return sum;
}


